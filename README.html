<HTML>
<HEAD>
<TITLE>ClearCase::Argv README</TITLE>
<LINK REV="made" HREF="mailto:dsb@cleartool.com">
</HEAD>

<BODY>

<A NAME="__index__"></A>
<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#readme">README</A></LI>
	<LI><A HREF="#summary of features">SUMMARY OF FEATURES</A></LI>
	<LI><A HREF="#chronology">CHRONOLOGY</A></LI>
	<UL>

		<LI><A HREF="#ipc::cleartool">IPC::ClearTool</A></LI>
		<LI><A HREF="#argv">Argv</A></LI>
		<LI><A HREF="#clearcase::argv">ClearCase::Argv</A></LI>
	</UL>

	<LI><A HREF="#grand unification">GRAND UNIFICATION</A></LI>
	<LI><A HREF="#release state">RELEASE STATE</A></LI>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="readme">README</A></H1>
<P>Though ClearCase::Argv is itself quite small, it represents the
<EM>``Grand Unification''</EM> of some of my other ClearCase-related modules.
The module itself is fully documented in the standard POD format; this
file is an accompanying overview and chronology.</P>
<P>
<HR>
<H1><A NAME="summary of features">SUMMARY OF FEATURES</A></H1>
<UL>
<LI><STRONG><A NAME="item_Interoperability%2FPortability">Interoperability/Portability</A></STRONG><BR>

Using <STRONG>ClearCase::Argv</STRONG> can enhance portability of scripts
between UNIX and Windows by providing versions of <EM>system</EM>, <EM>exec</EM>,
and <EM>qx</EM> (aka backquotes) which behave the same on Windows as on UNIX.
Ok, almost the same. This includes automatically quoting arguments to
protect them from the <CODE>cmd.exe</CODE> shell, automatically converting
/-separated pathnames to \, etc. Which can keep a lot of hair out
of your script.
<P></P>
<LI><STRONG><A NAME="item_Optional_Co%2DProcess_for_Speed">Optional Co-Process for Speed</A></STRONG><BR>

For any script which uses ClearCase::Argv, the 'ipc_cleartool' class
method
<PRE>
        ClearCase::Argv-&gt;ipc_cleartool;</PRE>
<P>will start <STRONG>cleartool</STRONG> as an <STRONG>IPC::ClearTool</STRONG> co-process and arrange to
send all subsequent system/exec/qx commands to it instead of forking a
new child process each time. This can speed up scripts by anywhere
between 1 (i.e. not at all) and 10 times by my measurements.</P>
<P></P>
<LI><STRONG><A NAME="item_Convenience_Features">Convenience Features</A></STRONG><BR>

Many convenience features are provided by the replacement
system/exec/qx functions. These include:
<PRE>
    1. 'autochomp' mode (chomps lines automatically, natch)
    2. 'autofail' mode (exit on child process failure)
    3. 'noexec' mode (print cmds without executing, like make -n)
    4. 'xargs' mode (breaks up long cmd lines to avoid system limits)</PRE>
<P>plus a few more.</P>
<P></P>
<LI><STRONG><A NAME="item_No_Major_Investment">No Major Investment</A></STRONG><BR>

It's easy to convert an existing script to use ClearCase::Argv or
back.  Just change all instances of backquotes to <CODE>qv()</CODE> and remove
any existing Win32-porting hackery. To go back to native style, either
change <CODE>qv()</CODE> to <CODE>qx()</CODE> (<EM>backquotes are generally deprecated in
favor of qx anyway</EM>), or add a line like:
<PRE>
        sub qv { qx(@_) }</PRE>
<P>And remove the 'use ClearCase::Argv' line of course.</P>
<P></P>
<LI><STRONG><A NAME="item_Option_Processing">Option Processing</A></STRONG><BR>

There's a great deal of option-processing power inherited from the
base class, much more in fact than most users will care about. Look
in the PODs for more.
<P></P></UL>
<P>
<HR>
<H1><A NAME="chronology">CHRONOLOGY</A></H1>
<P>
<H2><A NAME="ipc::cleartool">IPC::ClearTool</A></H2>
<P>I wrote <STRONG>IPC::ClearTool</STRONG> to manage <STRONG>cleartool</STRONG> as a co-process for
reasons of speed. I.e. instead of doing a fork/exec for each
<STRONG>cleartool</STRONG> command it forks just one process in the background and
sends all <STRONG>cleartool</STRONG> commands down to it. This is much (possibly up
to 10 times) faster.  Unfortunately <STRONG>IPC::ClearTool</STRONG> suffered from a
few paradigmatic flaws:</P>
<UL>
<LI>
It didn't work on Windows, where there's no such thing as a fork or
a true child process.
<P></P>
<LI>
The interface was/is strange and a little clunky. Not too surprising
considering that UNIX requires 3 different API's <CODE>(system, exec, and
backquotes)</CODE> to handle child processes; jamming all that functionality
into one API is awkward.
<P></P>
<LI>
Due to the above, any script written to the <STRONG>IPC::ClearTool</STRONG> API was
non-portable to Windows and hard to convert back to traditional
system/exec/qx. Thus converting an existing tool to it required a
substantial commitment of time, and using it at all meant a substantial
commitment of faith.
<P></P></UL>
<P>I was able to ``port'' <CODE>IPC::ClearTool</CODE> to Windows by calling into the
ClearCase Automation Library, a COM interface first available in
ClearCase 4.0 (it was actually present in unsupported form in 3.2.1).
But the other issues remained, until ...</P>
<P>
<H2><A NAME="argv">Argv</A></H2>
<P>I also had a ClearCase/Perl module called <STRONG>ClearCase::Ct</STRONG>.  This was a
wrapper that ran on top of <STRONG>cleartool</STRONG> to extend its functionality
and/or allow site policies to be established at the wrapper level. But
it suffered from an ugly programming model too (do we sense a trend
here?). In particular it was necessary to do lots of shifting,
grepping, splicing, and quoting of @ARGV, leading to terribly
spaghetti-like code in places, especially when you throw in the need
for UNIX/Windows portability and different shell-quoting rules. So
extensions written to the <STRONG>ClearCase::Ct</STRONG> ``API'' tended to resemble a
nest of ifdefs.</P>
<P>So I set out to rewrite <CODE>ClearCase::Ct</CODE>. The first step was to write a
support module (eventually called <STRONG>Argv</STRONG>) to hide all the @ARGV
machinations under an OO interface. Argv has plenty of its own docs so
I won't go into it here, but suffice it to say it provides lots of ways
to slice and dice an arg vector.  In fact it provides much more parsing
power than almost anyone would ever need, so while this was its
original reason for existence it's the least interesting to most.</P>
<P><STRONG>Argv</STRONG> also has <EM>execution methods</EM>, i.e. you can execute your Argv
object via <CODE>$obj-</CODE>system()&gt; or <CODE>$obj-</CODE>qx()&gt;. Handling platform
differences (quoting, pathname separators, etc.) in <STRONG>Argv</STRONG> seemed like
a natural extension, so I added that. This lead to convenience methods
like <CODE>$obj-</CODE>autochomp&gt; (should be obvious) and <CODE>$obj-</CODE>qxargs&gt;
(implements xargs-like behavior to ensure that system limits aren't
exceeded), etc.</P>
<P>At this point I realized that though the parsing features had a tiny
constituency, the portability abstraction of the <EM>execution methods</EM>
might be of interest to more users. So in order to make that more
accessible I added a <STRONG>functional interface</STRONG>, allowing the single line</P>
<PRE>
    use Argv qw(system exec qv);</PRE>
<P>to overrride the Perl builtins with Argv's relatively platform-
independent versions. Note: <EM>qv</EM> is used because Perl doesn't allow
<CODE>qx()</CODE>, which is itself a synonym for backquotes, to be overridden.
Bottom line, adding the above line - plus converting <CODE>`cmd`</CODE> to
<CODE>qv(&quot;cmd&quot;)</CODE> - buys a lot of UNIX/Win32 portability.</P>
<P>I eventually did get around to rewriting <EM>ClearCase::Ct</EM>; the
new module is called <STRONG>ClearCase::Wrapper</STRONG>.</P>
<P>
<H2><A NAME="clearcase::argv">ClearCase::Argv</A></H2>
<P>Note that <STRONG>Argv</STRONG> itself has nothing to do with ClearCase. So I made a
tiny subclass of <STRONG>Argv</STRONG> to tune it for use with <STRONG>cleartool</STRONG>, since I
write a lot of Perl/ClearCase code.  Originally, <STRONG>ClearCase::Argv</STRONG>
simply extended <STRONG>Argv</STRONG> to prepend the word ``cleartool'' to all arg
vectors. Thus, while</P>
<PRE>
    Argv-&gt;new('ls', -l');</PRE>
<P>represents an <CODE>&quot;ls -l&quot;</CODE> command,</P>
<PRE>
    ClearCase::Argv-&gt;new('ls', -l');</PRE>
<P>would run <CODE>&quot;cleartool ls -l&quot;</CODE>, and it understands that the 'program' part
of the command line is ``cleartool ci'' (or more properly qw(cleartool ci)).</P>
<P>The <EM>functional interface</EM> of <EM>Argv</EM> is exposed through
<STRONG>ClearCase::Argv</STRONG>, and it's also extended to support methods called
<STRONG>ccsystem(), ccexec(), and ccqx()</STRONG> which automatically prepend
'cleartool'. E.g.:</P>
<PRE>
        my @views = ccqx(lsview -s);</PRE>
<P>Attributes can be set through the functional interface like this:</P>
<PRE>
        my @views = ccqx({autochomp=&gt;1, dbglevel=&gt;0}, lsview -s);</PRE>
<P>
<HR>
<H1><A NAME="grand unification">GRAND UNIFICATION</A></H1>
<P>Then one day I got an email question from Mark Scandariato of
Lucent:</P>
<PRE>
    Do you have any plan to use IPC-ClearTool within ClearCase-Ct? (I'd
    hate to duplicate anything already underway.)</PRE>
<P>I replied that I didn't but it got me to thinking about whether
<CODE>ClearCase::Argv</CODE> could be taught to send its commands to a
co-process.  A few days later I got a chance to play with it and it
came together with surprising ease! This is the big connection that
makes it all pretty neat, IMHO, since you get improved speed,
portability, and ease of use in one package. Without having to make a
major commitment of rewriting code.</P>
<P>I should finish, though, by making clear that the ideal scenario
mentioned here has not gotten heavy testing. ClearCase::Argv (and by
extension Argv) per se are heavily used and pretty robust, but I
haven't gotten much chance to exercise the IPC::ClearTool connection.
All I can say is it's passed the few simple tests I've tried.</P>
<P>
<HR>
<H1><A NAME="release state">RELEASE STATE</A></H1>
<P>ClearCase::Argv is still considered in ``beta'' state, which I consider
to mean that it works pretty well but I reserve the right to make
interface changes. These are getting less likely, though.</P>

</BODY>

</HTML>
